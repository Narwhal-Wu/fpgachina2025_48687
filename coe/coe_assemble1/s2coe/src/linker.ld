/* ============================================================================
 * RISC-V RV32I Linker Script
 * 用于 RV32I 测试程序
 * ============================================================================ */

OUTPUT_FORMAT("elf32-littleriscv")  /* 指定输出格式为 32 位小端 RISC-V */
OUTPUT_ARCH(riscv)                  /* 指定架构 */
ENTRY(_start)                       /* 指定入口点为 _start */

/* ============================================================================
 * 内存布局定义
 * ============================================================================ */
MEMORY {
    /* 程序 RAM：从 0x0 开始，256KB 空间 */
    RAM (rwx) : ORIGIN = 0x00000000, LENGTH = 0x40000
    
    /* 外设映射区域：用于 LED 等 I/O */
    /* 注意：0xFFFFFFFC 实际在地址空间最高端，这里仅作标记 */
}

/* 栈大小定义 */
STACK_SIZE = 0x2000;  /* 8KB 栈空间 */

/* ============================================================================
 * 段定义
 * ============================================================================ */
SECTIONS {
    /* 起始地址 */
    . = ORIGIN(RAM);
    
    /* ========================================================================
     * .text 段 - 代码段（只读，可执行）
     * ======================================================================== */
    .text : ALIGN(4) {
        KEEP(*(.text.init))        /* 确保初始化代码在最前面 */
        KEEP(*(.text._start))      /* 确保 _start 在开头 */
        *(.text)                   /* 所有 .text 段 */
        *(.text.*)                 /* 支持多段（如 .text.startup） */
        . = ALIGN(4);              /* 4 字节对齐 */
    } > RAM
    
    _etext = .;                    /* 代码段结束地址 */
    
    /* ========================================================================
     * .rodata 段 - 只读数据段
     * ======================================================================== */
    .rodata : ALIGN(4) {
        *(.rodata)                 /* 只读数据 */
        *(.rodata.*)               /* 只读数据（多段） */
        *(.srodata)                /* 小只读数据 */
        *(.srodata.*)              
        . = ALIGN(4);
    } > RAM
    
    _erodata = .;                  /* 只读数据段结束 */

    /* ========================================================================
     * .data 段 - 初始化数据段（可读写）
     * ======================================================================== */
    .data : ALIGN(4) {
        _sdata = .;                /* 数据段起始地址 */
        *(.data)                   /* 初始化数据 */
        *(.data.*)                 
        *(.sdata)                  /* 小数据段 */
        *(.sdata.*)                
        . = ALIGN(4);
        _edata = .;                /* 数据段结束地址 */
    } > RAM

    /* ========================================================================
     * .bss 段 - 未初始化数据段（零初始化）
     * ======================================================================== */
    .bss : ALIGN(4) {
        _sbss = .;                 /* BSS 段起始地址 */
        *(.bss)                    /* 未初始化数据 */
        *(.bss.*)                  
        *(.sbss)                   /* 小 BSS */
        *(.sbss.*)                 
        *(COMMON)                  /* 公共符号 */
        . = ALIGN(4);
        _ebss = .;                 /* BSS 段结束地址 */
    } > RAM

    /* ========================================================================
     * 堆和栈区域
     * ======================================================================== */
    . = ALIGN(4);
    _end = .;                      /* 程序数据结束，堆起始位置 */
    _heap_start = .;               /* 堆起始地址 */
    
    /* 栈从 RAM 顶部向下增长 */
    . = ORIGIN(RAM) + LENGTH(RAM) - STACK_SIZE;
    . = ALIGN(16);                 /* 16 字节对齐（RISC-V ABI 要求） */
    _stack_start = .;              /* 栈底（低地址） */
    . = . + STACK_SIZE;
    _stack_top = .;                /* 栈顶（高地址，sp 初始值） */
    
    _heap_end = _stack_start;      /* 堆结束于栈开始处 */

    /* ========================================================================
     * 调试和丢弃段
     * ======================================================================== */
    /* 保留调试信息但不加载到内存 */
    .debug_info     0 : { *(.debug_info) }
    .debug_abbrev   0 : { *(.debug_abbrev) }
    .debug_line     0 : { *(.debug_line) }
    .debug_frame    0 : { *(.debug_frame) }
    .debug_str      0 : { *(.debug_str) }
    .debug_loc      0 : { *(.debug_loc) }
    .debug_ranges   0 : { *(.debug_ranges) }
    
    /* 丢弃不需要的段 */
    /DISCARD/ : {
        *(.note.*)
        *(.comment)
        *(.eh_frame)
    }
}

/* ============================================================================
 * 符号检查和断言
 * ============================================================================ */
/* 确保程序不超出 RAM 范围 */
ASSERT(_stack_top <= (ORIGIN(RAM) + LENGTH(RAM)), "ERROR: Stack overflows RAM!")
ASSERT(_end < _stack_start, "ERROR: Program data overlaps with stack!")

/* 提供有用的信息符号 */
PROVIDE(_ram_start = ORIGIN(RAM));
PROVIDE(_ram_end = ORIGIN(RAM) + LENGTH(RAM));
PROVIDE(_ram_size = LENGTH(RAM));